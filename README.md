# Chapter 1
## Example 1
## Example 2
## Example 3
- Thread life cycle
  - `NEW`
  - `RUNNABLE`
  - `WAITING`
    - wait()와 notify() 메서드는 Object 클래스에 정의 Java의 동기화 메커니즘에서 중요한 역할 수행. 
    - 이 메서드들은 반드시 동기화된(synchronized) 컨텍스트에서만 사용할 수 있음. 즉, wait(), notify(), notifyAll() 메서드는 동기화 블록 또는 동기화 메서드 내에서만 호출가능.
      - synchronized 키워드를 사용하면, 메서드나 블록을 실행하는 스레드는 해당 객체의 락을 획득함
      - wait() 메서드의 정의에 따르면, 스레드가 객체의 락을 소유한 상태에서만 대기 상태로 들어갈 수 있음. 이러한 규칙을 위반할 경우 IllegalMonitorStateException 예외 발생
      - notify()나 notifyAll() 메서드를 호출하는 다른 스레드가 있을 경우, 대기 상태에 있던 스레드 중 하나(또는 전부)가 깨어나 락을 다시 획득하고 계속 실행함. 이 과정에서 동기화는 락의 소유권을 안전하게 전달하기 위한 필수요소 
  - `TIMED_WAITING`
  - `BLOCKED`
  - `TERMINATED`

# Chapter 2
# Chapter 3
# Chapter 4
# Chapter 5
## Example 3
- 키워드 `synchronized`
  - Java에서 동기화를 위해 사용
  - 메서드 수준에서의 Synchronized
    ```java
    public synchronized void method() {
    // 동기화된 메서드 내용
    }
    ```
    - 해당 메서드가 포함된 객체의 락(lock)을 획득해야만 해당 메서드를 실행할 수 있음을 의미
    - 메서드 수준의 동기화는 메서드가 시작될 때 자동으로 락을 획득하고, 메서드가 종료되면 락을 자동으로 해제
  - 블록 수준에서의 Synchronized
      ```java
      public void method() {
        synchronized(this) {
        // 동기화된 블록 내용
        }
      }
      ```
    - 동기화 블록은 더 세밀한 동기화 제어를 가능하게 함, 필요한 부분에만 동기화를 적용할 수 있어 메서드 전체를 동기화하는 것보다 성능상 이점이 있음
# Chapter 6
## Example 1
- Mutex
  - 동시에 여러 스레드나 프로세스가 같은 자원에 접근하는 것을 방지하기 위한 동기화 매커니즘
  - 한 번에 하나의 스레드만이 자원에 접근하도록 함으로써 경쟁 상태(Race Condition)으로 인한 문제들을 방지함
- Semaphore
  - 다수의 스레드가 공유 자원에 접근하는 것을 제어하는 방법. 기본적으로 특정 자원에 대한 접근을 제한하는 카운터로 생각할 수 있음
    - 카운터 값: 세마포어는 내부적으로 카운터 값을 보유함. 동시에 리소스에 접근할 수 있는 스레드의 최대 수를 의미함 
    - acquire(): 스레드가 리소스에 접근하려고 할 때 호출. 세마포어의 카운터 값을 감소시키고, 카운터 값이 0이면 리소스에 접근할 수 있는 권한이 없으므로 스레드는 대기 상태가 됨. 
    - release(): 스레드가 리소스 사용을 완료하고 다른 스레드가 접근할 수 있도록 하기 위해 호출. 세마포어의 카운터 값을 증가시킴.
  - Binary Semaphore
    - 카운터 값으로 0 또는 1만 가질 수 있는 세마포어. 바이너리 세마포어는 뮤텍스와 유사하게 작동하며, 주로 리소스의 상호 배제를 위해 사용
    - 뮤텍스(Mutex)와 바이너리 세마포어(Binary Semaphore)는 모두 상호 배제(Mutual Exclusion)를 보장하기 위해 사용되지만, 몇 가지 차이점이 있음
      - 뮤텍스는 소유권 개념을 가지고 있음. 즉, 뮤텍스를 잠금한 스레드만이 해당 뮤텍스를 해제할 수 있음. 바이너리 세마포어는 소유권 개념이 없음. 어떤 스레드든 세마포어를 획득할 수 있으며, 다른 스레드가 세마포어를 해제할 수도 있습니다. 이는 뮤텍스보다 유연성을 제공하지만, 오용할 경우 문제를 일으킴.
      - 뮤텍스는 주로 데이터의 상호 배제를 보장하기 위해 사용하지만, 바이너리 세마포어는 상호 배제뿐만 아니라, 시그널링(signaling) 메커니즘으로도 사용할 수 있음. 즉, 하나의 스레드가 다른 스레드에게 특정 이벤트나 조건의 발생을 알리는 데 사용 가능
  - Counting Semaphore
    - 카운터 값으로 0 이상의 값을 가질 수 있는 세마포어. 카운팅 세마포어는 여러 스레드가 동시에 리소스에 접근할 수 있도록 허용하며, 리소스의 개수를 제한하는 데 사용
- Condition Synchronization (조건 동기화)
  - 조건 동기화(Condition Synchronization)는 멀티 스레딩 환경에서 특정 조건이 만족될 때까지 스레드를 대기시키고, 해당 조건이 만족되면 스레드를 깨우는 메커니즘. 
  - 스레드가 특정 조건이 충족되기를 기다린 후 작업을 수행해야 할 때 유용. 자원의 낭비 없이 효율적인 작업 수행을 도모할 수 있음.
  - 대기(Wait): 특정 조건이 만족되지 않았을 때, 스레드는 조건이 충족될 때까지 대기. 대기 중인 스레드는 CPU 시간을 소비하지 않음. 
  - 알림(Notify): 조건이 충족되면, 대기 중인 스레드 중 하나 또는 모든 스레드에게 알림을 보내어 작업을 계속할 수 있도록 함.


# Chapter 7
# Chapter 8
# Chapter 9
# Chapter 10
# Chapter 11